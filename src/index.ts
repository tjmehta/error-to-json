import {AssertionError} from 'assert'

import stringify from 'fast-safe-stringify'

export default errToJSON


const nonEnumerablePropsToCopy = [
  'code', 'cause', 'errno', 'message', 'name', 'stack', 'syscall'
]


let AssertionError_toJSON: Function | undefined
let Error_toJSON: Function | undefined


function Error_prototype_toJSON(this: Error) {
  const json = {...this}

  for(const key of nonEnumerablePropsToCopy)
    // @ts-ignore
    if (key in this) json[key] = this[key]

  return JSON.parse(stringify(json))
}

export function disable()
{
  // @ts-ignore
  if (AssertionError.prototype.toJSON === Error_prototype_toJSON) {
    // @ts-ignore
    AssertionError.prototype.toJSON = AssertionError_toJSON
    AssertionError_toJSON = undefined
  }

  // @ts-ignore
  if (Error.prototype.toJSON === Error_prototype_toJSON) {
    // @ts-ignore
    Error.prototype.toJSON = Error_toJSON
    Error_toJSON = undefined
  }
}

export function enable()
{
  // @ts-ignore
  if (Error.prototype.toJSON === Error_prototype_toJSON) return

  // AssertionError
  // @ts-ignore
  ;({toJSON: AssertionError_toJSON} = AssertionError.prototype)
  // @ts-ignore
  AssertionError.prototype.toJSON = Error_prototype_toJSON

  // Error
  // @ts-ignore
  ;({toJSON: Error_toJSON} = Error.prototype)
  // @ts-ignore
  Error.prototype.toJSON = Error_prototype_toJSON
}

export function errToJSON<T extends {}>(json: any): T {
  enable()

  // Get JSON representation of objects
  if(json.toJSON) json = json.toJSON()
  else if(isErrorAlike(json)) json = Error_prototype_toJSON.call(json)

  disable()

  // return error json
  return json
}

// HACK: found on the wild an `AssertionError` that extends from non default
//       `Error` class.
function isErrorAlike(error: any): boolean {
  return error != null
      // TODO: Both can be `undefined`, how can we properly detect them? See
      // https://tc39.es/ecma262/multipage/fundamental-objects.html#sec-error.prototype.tostring
      && typeof error.message === 'string'
      && typeof error.name === 'string'
      // 'stack' is not standard, but widely supported, see
      // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error/stack
      && 'stack' in error
}

export function parse(
  json: ({errors?: any[], name: 'AggregateError'} | {name?: string})
    & {cause: any, message: string, stack?: string},
  constructors: Record<string, new(message?: string) => Error> = {}
) {
  const {message, name} = json

  let {cause} = json

  if((cause as {message: string})?.message !== undefined)
    cause = parse(cause, constructors)

  let err: Error

  switch (name) {
    case 'AggregateError':
      err = new AggregateError(
        ((json as {errors?: any[]}).errors ?? []).map(function(error) {
          return parse(error, constructors)
        }),
        message, {cause}
      )
      break;

    case 'EvalError':
    case 'RangeError':
    case 'ReferenceError':
    case 'SyntaxError':
    case 'TypeError':
    case 'URIError':
      err = new globalThis[name](message, {cause})
      break;

    default:
      {
        const Constructor = constructors[name as keyof typeof constructors]

        err = Constructor
          ? new Constructor(message)
          : new Error(message, {cause})
      }
    }

  const {stack} = err

  Object.assign(err, json)
  for(const key of nonEnumerablePropsToCopy)
    // @ts-ignore
    if (key in json) err[key] = json[key]

  if (stack !== undefined && err.stack === stack) {
    // remove stacktrace generated by error constructor above
    const index = stack.indexOf('\n')
    err.stack = stack.slice(0, index) + stack.slice(stack.indexOf('\n', index + 1))
  }
  return err
}
